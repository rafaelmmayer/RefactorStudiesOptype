using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenarator;

[Generator]
public class StudyTypesGenerator : IIncrementalGenerator
{
    private const string BaseClassFullName = "Core.Domain.Studies.StudyType";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Pipeline: Encontrar classes candidatas
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateClass(node),
                transform: static (ctx, _) => GetClassSymbolIfInherits(ctx)
            )
            .Where(static symbol => symbol is not null) // Filtra os nulos
            .Collect(); // Coleta todos em um array

        // 2. Output: Gerar o código final
        context.RegisterSourceOutput(provider, static (spc, symbols) =>
        {
            Execute(spc, symbols!);
        });
    }

    // Verifica sintaxe básica (é classe? não é abstrata?)
    private static bool IsCandidateClass(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl
               && !classDecl.Modifiers.Any(m => m.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.AbstractKeyword))
               && !classDecl.Modifiers.Any(m => m.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.StaticKeyword));
    }

    // Transforma Syntax em Symbol e verifica herança
    private static INamedTypeSymbol? GetClassSymbolIfInherits(GeneratorSyntaxContext context)
    {
        // Tenta obter o símbolo da classe
        if (context.Node is not ClassDeclarationSyntax classDeclaration)
            return null;

        if (context.SemanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol symbol)
            return null;

        // Percorre a herança
        var baseType = symbol.BaseType;

        while (baseType != null)
        {
            var baseName = baseType
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .Replace("global::", string.Empty);

            if (baseName == BaseClassFullName)
                return symbol;

            baseType = baseType.BaseType;
        }

        return null;
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> symbols)
    {
        if (symbols.IsDefaultOrEmpty) return;

        var sb = new StringBuilder();

        // Cabeçalho
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace Core.Domain.Studies.Types;");
        sb.AppendLine();
        sb.AppendLine("public static class StudyTypes");
        sb.AppendLine("{");

        // Lista para guardar os nomes das propriedades para usar no array depois
        var propertyNames = new List<string>();

        // Gerar propriedades estáticas
        foreach (var symbol in symbols)
        {
            // Ex: global::Core.Domain.Studies.Types.Alvenaria.AlvenariaStudyType
            var fullClassName = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            
            // Define o nome da propriedade (Ex: remove "StudyType" do nome da classe para ficar bonito)
            // AlvenariaStudyType -> Alvenaria
            var propertyName = symbol.Name.EndsWith("StudyType") 
                ? symbol.Name.Substring(0, symbol.Name.Length - "StudyType".Length) 
                : symbol.Name;

            propertyNames.Add(propertyName);

            // Gera: public static readonly global::Core.Domain.Studies.StudyType Alvenaria = new global::...();
            sb.AppendLine($"    public static readonly global::{BaseClassFullName} {propertyName} = new {fullClassName}();");
        }

        // Gerar o Array List
        sb.AppendLine();
        sb.AppendLine($"    public static global::{BaseClassFullName}[] List => new global::{BaseClassFullName}[]");
        sb.AppendLine("    {");
        
        foreach (var propName in propertyNames)
        {
            sb.AppendLine($"        {propName},");
        }

        sb.AppendLine("    };");
        sb.AppendLine("}");

        context.AddSource("StudyTypes.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}