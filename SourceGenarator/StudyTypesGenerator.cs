using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenarator;

[Generator]
public class StudyTypesListGenerator : IIncrementalGenerator
{
    private const string TargetInterface = "Core.Domain.Studies.IStudyType";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var studyTypesProvider = context
            .SyntaxProvider.CreateSyntaxProvider(
                predicate: (syntax, _) => IsCandidateClass(syntax),
                transform: (ctx, _) => GetSemanticTarget(ctx)
            )
            .Where(t => t is not null)
            .Collect();

        // 2. Registrar a saída usando a coleção completa
        context.RegisterSourceOutput(studyTypesProvider, GenerateCode);
    }

    private static bool IsCandidateClass(SyntaxNode node)
    {
        // Filtro rápido sintático
        return node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 } c
            && c.Modifiers.All(m => m.ValueText != "abstract");
    }

    private static INamedTypeSymbol? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

        if (symbol is null)
            return null;

        // Verifica se implementa a interface específica
        // Também é bom garantir que a classe tenha um construtor sem parâmetros
        var hasInterface = symbol.AllInterfaces.Any(i => i.ToDisplayString() == TargetInterface);
        var hasParameterlessCtor = symbol.InstanceConstructors.Any(c =>
            c.Parameters.Length == 0 && !c.IsStatic
        );

        return (hasInterface && hasParameterlessCtor) ? symbol : null;
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<INamedTypeSymbol?> symbols
    )
    {
        if (symbols.IsDefaultOrEmpty)
            return;

        // Remover duplicatas e nulos (por segurança)
        var uniqueSymbols = symbols
            .Where(s => s is not null)
            .Distinct(SymbolEqualityComparer.Default)
            .Cast<INamedTypeSymbol>()
            .OrderBy(s => s.Name) // Ordenar para garantir output determinístico
            .ToList();

        if (uniqueSymbols.Count == 0)
            return;

        var sb = new StringBuilder();

        // Cabeçalho
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine();

        // Se quiser colocar a classe gerada em um namespace específico, ajuste aqui:
        sb.AppendLine("namespace Core.Domain.Studies.Types;");
        sb.AppendLine();
        sb.AppendLine("public static class StudyTypes");
        sb.AppendLine("{");

        // Gerar as propriedades estáticas
        foreach (var symbol in uniqueSymbols)
        {
            var className = symbol.Name;
            if (className.EndsWith("StudyType"))
            {
                className = className.Replace("StudyType", string.Empty);
            }

            var fullClassName = symbol.ToDisplayString();

            // Ex: public static readonly IStudyType StudyType1 = new Full.Namespace.StudyType1();
            sb.AppendLine(
                $"    public static readonly {TargetInterface} {className} = new {fullClassName}();"
            );
        }

        sb.AppendLine();

        // Gerar a lista agregada
        sb.AppendLine(
            $"    public static readonly {TargetInterface}[] List = new {TargetInterface}[]"
        );
        sb.AppendLine("    {");

        foreach (var symbol in uniqueSymbols)
        {
            var symbolName = symbol.Name;
            if (symbolName.EndsWith("StudyType"))
            {
                symbolName = symbolName.Replace("StudyType", string.Empty);
            }

            sb.AppendLine($"        {symbolName},");
        }

        sb.AppendLine("    };");
        sb.AppendLine("}");

        context.AddSource("StudyTypes.g.cs", sb.ToString());
    }
}
